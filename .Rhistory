#setDF(datKME)
#datKME %>% dplyr::select(datKME, matches(paste(MMsigmods, collapse="|")))
#datKME[,c(sigmods)]
#sigmorphmodules <- datKME[,c("MM.pink", "MM.purple", "MM.grey")]
# loop to make ordered outputs for GOrilla
for (i in 1:length(MMstagesigmods)){
modcol <- MMstagesigmods[i]
# get data for module color
tmp <- datKME[,modcol]
gene_rows <- rownames(datKME)
tmp <- as.data.frame(cbind(gene_rows, as.numeric(tmp)))
colnames(tmp) <- c("gene", "module.membership")
tmp$module.membership <- as.numeric(as.character(tmp$module.membership))
tmp <- tmp[order(tmp[2], decreasing = TRUE), ]
write.csv(tmp, paste0("results/WGCNAresults/vco2_", modcol, "ModuleMembership.csv"), row.names = FALSE)
}
MMrqigmods <- gsub(pattern = "ME", replacement = "MM.", rqigmods)
#setDF(datKME)
#datKME %>% dplyr::select(datKME, matches(paste(MMsigmods, collapse="|")))
#datKME[,c(sigmods)]
#sigmorphmodules <- datKME[,c("MM.pink", "MM.purple", "MM.grey")]
# loop to make ordered outputs for GOrilla
for (i in 1:length(MMrqigmods)){
modcol <- MMrqigmods[i]
# get data for module color
tmp <- datKME[,modcol]
gene_rows <- rownames(datKME)
tmp <- as.data.frame(cbind(gene_rows, as.numeric(tmp)))
colnames(tmp) <- c("gene", "module.membership")
tmp$module.membership <- as.numeric(as.character(tmp$module.membership))
tmp <- tmp[order(tmp[2], decreasing = TRUE), ]
write.csv(tmp, paste0("results/WGCNAresults/rq_", modcol, "ModuleMembership.csv"), row.names = FALSE)
}
MMh2oigmods <- gsub(pattern = "ME", replacement = "MM.", h2oigmods)
#setDF(datKME)
#datKME %>% dplyr::select(datKME, matches(paste(MMsigmods, collapse="|")))
#datKME[,c(sigmods)]
#sigmorphmodules <- datKME[,c("MM.pink", "MM.purple", "MM.grey")]
# loop to make ordered outputs for GOrilla
for (i in 1:length(MMh2oigmods)){
modcol <- MMh2oigmods[i]
# get data for module color
tmp <- datKME[,modcol]
gene_rows <- rownames(datKME)
tmp <- as.data.frame(cbind(gene_rows, as.numeric(tmp)))
colnames(tmp) <- c("gene", "module.membership")
tmp$module.membership <- as.numeric(as.character(tmp$module.membership))
tmp <- tmp[order(tmp[2], decreasing = TRUE), ]
write.csv(tmp, paste0("results/WGCNAresults/h2o_", modcol, "ModuleMembership.csv"), row.names = FALSE)
}
# countdata
#WGCNAdata <- countdata
#names(WGCNAdata)=str_sub(names(WGCNAdata),2)
#  #read.table("data/gene.level.count.data.tsv", header = TRUE, sep = "\t")
## sample information
#WGCNAsamples <- read.csv("results/samplespreadsheet.csv")
#WGCNAdata <- dplyr::select(countdata, contains("kid"))
#WGCNAsamples <-samples %>% filter(tissue == "kid")
#kept running out of space
#WGCNAdata <- dplyr::select(countdata, contains("lu"))
#WGCNAsamples <-samples %>% filter(tissue == "lu")
#
#WGCNAdata <- dplyr::select(countdata, contains("liv"))
#WGCNAsamples <-samples %>% filter(tissue == "liv")
#
#WGCNAdata <- dplyr::select(countdata, contains("hyp"))
#WGCNAsamples <-samples %>% filter(tissue == "hyp")
#
#left off here
WGCNAdata <- dplyr::select(countdata, contains("gi"))
WGCNAsamples <-samples %>% filter(tissue == "gi")
# create DESeq dataset
dds <- DESeqDataSetFromMatrix(countData = WGCNAdata,
colData = WGCNAsamples,
design = ~ sex + trt )
## using counts imported via tximports from above
vsd <- vst(dds, blind = FALSE)
vsd <- assay(vsd)
# transpose, as required by WGCNA
vsd <- as.data.frame(t(vsd))
# check if there are gene outliers
gsg = goodSamplesGenes(vsd, verbose = 3)
gsg$allOK
# remove any offenders
#if (!gsg$allOK)
#  {if (sum(!gsg$goodGenes)>0)
#printFlush(paste("Removing genes:", paste(names(vsd)[!gsg$goodGenes], collapse= ", ")));
#if (sum(!gsg$goodSamples)>0)
#printFlush(paste("Removing samples:", paste(rownames(vsd)[!gsg$goodSamples], collapse=", ")))
#vsd <- vsd[gsg$goodSamples, gsg$goodGenes]
#}
# verify data and sample information align
table(WGCNAsamples$individal==rownames(vsd))
# drop lane
#WGCNAsamples <- dplyr::select(WGCNAsamples, -c(filename,lane))
# make sample id row name...
WGCNAsamples <- data.frame(WGCNAsamples[,-1], row.names=WGCNAsamples[,1])
A = adjacency(t(vsd),type="signed") # this calculates the whole network connectivity
k = as.numeric(apply(A,2,sum))-1 # standardized connectivity
Z.k = scale(k)
thresholdZ.k = -2.5 # often -2.5
outlierColor = ifelse(Z.k<thresholdZ.k,"red","black")
sampleTree = flashClust(as.dist(1-A), method = "average")
# Convert traits to a color representation where red indicates high values
# needs to be numeric
WGCNAsamples$sex <- as.numeric(as.factor(WGCNAsamples$sex))
WGCNAsamples$trt <- as.numeric(as.factor(WGCNAsamples$trt))
#WGCNAsamples$tissue <- as.numeric(as.factor(WGCNAsamples$tissue))
drop <- c("experiment.", "filename", "sample", "tissue", "individal")
WGCNAsamples <- WGCNAsamples[,!(names(WGCNAsamples) %in% drop)]
traitColors = data.frame(numbers2colors(WGCNAsamples,signed=FALSE))
dimnames(traitColors)[[2]] = paste(names(WGCNAsamples))
datColors = data.frame(outlier = outlierColor,traitColors)
plotDendroAndColors(sampleTree,groupLabels=names(datColors),
colors=datColors,main="Sample Dendrogram and Trait Heatmap")
powers = c(c(1:10), seq(from =10, to=30, by=1)) #choosing a set of soft-thresholding powers
sft = pickSoftThreshold(vsd, powerVector=powers, verbose =5, networkType="signed") #call network topology analysis function
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], xlab= "Soft Threshold (power)", ylab="Scale Free Topology Model Fit, signed R^2", type= "n", main= paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers, col="red")
abline(h=0.90, col="red")
plot(sft$fitIndices[,1], sft$fitIndices[,5], xlab= "Soft Threshold (power)", ylab="Mean Connectivity", type="n", main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, col="red")
allowWGCNAThreads()
net = blockwiseModules(vsd, power = 10,
TOMType = "unsigned", minModuleSize = 30,
reassignThreshold = 0, mergeCutHeight = 0.25,
numericLabels = TRUE, pamRespectsDendro = FALSE,
saveTOMs = TRUE,
saveTOMFileBase = "giGenesTOM",
verbose = 3)
table(net$colors)
# Convert labels to colors for plotting
mergedColors = labels2colors(net$colors)
# Plot the dendrogram and the module colors underneath
plotDendroAndColors(net$dendrograms[[1]], mergedColors[net$blockGenes[[1]]],
"Module colors",
dendroLabels = FALSE, hang = 0.03,
addGuide = TRUE, guideHang = 0.05)
#Define number of genes and samples
nGenes = ncol(vsd)
nSamples = nrow(vsd)
#Recalculate MEs with color labels
MEs0 = moduleEigengenes(vsd, mergedColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, WGCNAsamples, use= "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)
#Print correlation heatmap between modules and traits
textMatrix= paste(signif(moduleTraitCor, 2), "\n(",
signif(moduleTraitPvalue, 1), ")", sep= "")
dim(textMatrix)= dim(moduleTraitCor)
par(mar= c(6, 8.5, 3, 3))
#display the corelation values with a heatmap plot
labeledHeatmap(Matrix= moduleTraitCor,
xLabels= names(WGCNAsamples),
yLabels= gsub(pattern = "ME", replacement = "", names(MEs)),
ySymbols= names(MEs),
colorLabels= FALSE,
colors= blueWhiteRed(50),
textMatrix= textMatrix,
setStdMargins= FALSE,
cex.text= 0.5,
zlim= c(-1,1),
main= paste("Module-trait relationships"))
# save to disk
png("figures/giWGCNA_heatmap.png", width = 9.5, height = 7, units = "in", res = 300)
par(mar= c(6, 12, 3, 3))
labeledHeatmap(Matrix= moduleTraitCor,
xLabels= names(WGCNAsamples),
yLabels= gsub(pattern = "ME", replacement = "", names(MEs)),
ySymbols= gsub(pattern = "ME", replacement = "", names(MEs)),
colorLabels= FALSE,
colors= blueWhiteRed(50),
textMatrix= textMatrix,
setStdMargins= FALSE,
cex.text= 0.5,
zlim= c(-1,1),
main= paste("Module-trait relationships"))
dev.off()
datME=moduleEigengenes(vsd,mergedColors)$eigengenes
datKME=signedKME(vsd, datME, outputColumnName="MM.")
genes=names(vsd)
geneInfo0 = data.frame(gene=genes,moduleColor=mergedColors)
color=data.frame(geneInfo0,datKME) #these are from your original WGCNA analysis
head(color)
write.csv(as.data.frame(color), file = "results/giGeneModule_membership.csv")
#### MM pvalues
modNames = substring(names(MEs), 3)
geneModuleMembership = as.data.frame(cor(vsd, MEs, use = "p"));
MMPvalue=as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
pvals=data.frame(geneModuleMembership,MMPvalue)
head(pvals)
write.csv(as.data.frame(pvals), file = "results/giGeneModule_membership_pvalues.csv")
whichTrait="trt" #Replace this with the trait of interest
trt = as.data.frame(WGCNAsamples$trt);
names(trt) = "trt"
# names (colors) of the modules
modNames = substring(names(MEs), 3)
geneModuleMembership = as.data.frame(cor(vsd, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
geneTraitSignificance = as.data.frame(cor(vsd, trt, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
names(geneTraitSignificance) = paste("GS.", names(trt), sep="");
names(GSPvalue) = paste("p.GS.", names(trt), sep="")
# subets out only significant modules
modulePs <- as.data.frame(moduleTraitPvalue)
trtsigmods <- rownames(subset(modulePs, trt < 0.05))
print(paste0("Number of significant modules by trt: ", length(trtsigmods)))
sexigmods <- rownames(subset(modulePs, sex < 0.05))
print(paste0("Number of significant modules by sex: ", length(sexigmods)))
vo2igmods <- rownames(subset(modulePs, mean_VO2 < 0.05))
print(paste0("Number of significant modules by vo2: ", length(vo2igmods)))
vco2igmods <- rownames(subset(modulePs, mean_VCO2 < 0.05))
print(paste0("Number of significant modules by vco2: ", length(vco2igmods)))
eeigmods <- rownames(subset(modulePs, mean_EE < 0.05))
print(paste0("Number of significant modules by ee: ", length(eeigmods)))
rqigmods <- rownames(subset(modulePs, mean_RQ < 0.05))
print(paste0("Number of significant modules by rq: ", length(rqigmods)))
h2oigmods <- rownames(subset(modulePs, mean_H2Omg < 0.05))
print(paste0("Number of significant modules by h2o: ", length(h2oigmods)))
sigmods <- rownames(modulePs[rowSums(modulePs < 0.05) >= 1, ])
print(paste0("Number of unique significant modules by any variable: ", length(sigmods)))
# get info for any of these with p values (example = stages):
# format(subset(modulePs, morph < 0.05), scientific = FALSE)
#
# remove "ME" from all sigmods
sigmods <- gsub(pattern = "ME", replacement = "", sigmods)
probes = names(vsd)
nTop = 30
moduleColors=mergedColors
adj = adjacency(vsd, power = 10, type = "signed") #specify network type
## Translate adjacency into topological overlap matrix and calculate the corresponding dissimilarity
TOM = TOMsimilarity(adj, TOMType="signed") #Topological Overlap Matrix
dissTOM = 1-TOM
for(i in 1:length(unique(sigmods))){
#inModule = sigmods[i];
#modProbes = probes[inModule];
inModule = (moduleColors == sigmods[i]);
modProbes = probes[inModule];
## Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modProbes, modProbes)
## Genes with highest connectivity within each significant module
IMConn = softConnectivity(vsd[, modProbes])
top = (rank(-IMConn) <= nTop)
tempdat<-data.frame(IMConn,modProbes)[order(-IMConn),]
names(tempdat)<-c("IMConnectivity","target_id")
tempdat$ModuleColor <- rep(sigmods[i],nrow(tempdat))
#tempdat2 = left_join(tempdat,preGO1, by = "target_id")
write.csv(tempdat, paste("results/WGCNAresults/giHubGenes",sigmods[i],".csv",sep="_"), na="", row.names=FALSE)
}
## List all the files
temp <- list.files(path = "results/WGCNAresults", pattern = "*HubGenes")
temp <- paste("results/WGCNAresults/", temp, sep = "")
Hub_genes = do.call(rbind, lapply(temp, function(x) read.csv(x, stringsAsFactors = FALSE)))
write.csv(Hub_genes, paste("results/WGCNAresults/giHubGenes_all.csv",sep="_"), na="", row.names=FALSE)
# Recalculate topological overlap if needed
#TOM = TOMsimilarityFromExpr(vsd, power = 10)
# Select modules
sigmods # Lists modules of interest
module = "purple"
moduleColors = mergedColors
# Select module probes
probes = names(vsd)
inModule = is.finite(match(moduleColors, module));
modProbes = probes[inModule];
#modGenes = annote_df$gene_name[match(modProbes, annote_df$target_id)];
# Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modProbes, modProbes)
cyt = exportNetworkToCytoscape(modTOM,
edgeFile = paste("results/WGCNAresults/giCytoscapeInput-edges-", paste(module, collapse="-"), ".txt"),
nodeFile = paste("results/WGCNAresults/giCytoscapeInput-nodes-", paste(module, collapse="-"), ".txt"),
weighted = TRUE,
threshold = 0.175, # Change to get about 30
nodeNames = modProbes,
#altNodeNames = modGenes,
nodeAttr = moduleColors[inModule]);
cyt
## Record of thresholds:
# Dark grey - 0.02
# light green - 0.1
# blue - 0.4
# darkgreen - 0.02
# darkturquoise - 0.1
# red = 0.4
# turquoise = 0.4
# salmon = 0.15
#cytoscapePing()
MMmorphsigmods <- gsub(pattern = "ME", replacement = "MM.", trtsigmods)
#setDF(datKME)
#datKME %>% dplyr::select(datKME, matches(paste(MMsigmods, collapse="|")))
#datKME[,c(sigmods)]
#sigmorphmodules <- datKME[,c("MM.pink", "MM.purple", "MM.grey")]
# loop to make ordered outputs for GOrilla
for (i in 1:length(MMmorphsigmods)){
modcol <- MMmorphsigmods[i]
# get data for module color
tmp <- datKME[,modcol]
gene_rows <- rownames(datKME)
tmp <- as.data.frame(cbind(gene_rows, as.numeric(tmp)))
colnames(tmp) <- c("gene", "module.membership")
tmp$module.membership <- as.numeric(as.character(tmp$module.membership))
tmp <- tmp[order(tmp[2], decreasing = TRUE), ]
write.csv(tmp, paste0("results/WGCNAresults/trt_", modcol, "ModuleMembership.csv"), row.names = FALSE)
}
MMspeciessigmods <- gsub(pattern = "ME", replacement = "MM.", sexigmods)
#setDF(datKME)
#datKME %>% dplyr::select(datKME, matches(paste(MMsigmods, collapse="|")))
#datKME[,c(sigmods)]
#sigmorphmodules <- datKME[,c("MM.pink", "MM.purple", "MM.grey")]
# loop to make ordered outputs for GOrilla
for (i in 1:length(MMspeciessigmods)){
modcol <- MMspeciessigmods[i]
# get data for module color
tmp <- datKME[,modcol]
gene_rows <- rownames(datKME)
tmp <- as.data.frame(cbind(gene_rows, as.numeric(tmp)))
colnames(tmp) <- c("gene", "module.membership")
tmp$module.membership <- as.numeric(as.character(tmp$module.membership))
tmp <- tmp[order(tmp[2], decreasing = TRUE), ]
write.csv(tmp, paste0("results/WGCNAresults/sex_", modcol, "ModuleMembership.csv"), row.names = FALSE)
}
MMstagesigmods <- gsub(pattern = "ME", replacement = "MM.", vco2igmods)
#setDF(datKME)
#datKME %>% dplyr::select(datKME, matches(paste(MMsigmods, collapse="|")))
#datKME[,c(sigmods)]
#sigmorphmodules <- datKME[,c("MM.pink", "MM.purple", "MM.grey")]
# loop to make ordered outputs for GOrilla
for (i in 1:length(MMstagesigmods)){
modcol <- MMstagesigmods[i]
# get data for module color
tmp <- datKME[,modcol]
gene_rows <- rownames(datKME)
tmp <- as.data.frame(cbind(gene_rows, as.numeric(tmp)))
colnames(tmp) <- c("gene", "module.membership")
tmp$module.membership <- as.numeric(as.character(tmp$module.membership))
tmp <- tmp[order(tmp[2], decreasing = TRUE), ]
write.csv(tmp, paste0("results/WGCNAresults/vco2_", modcol, "ModuleMembership.csv"), row.names = FALSE)
}
MMrqigmods <- gsub(pattern = "ME", replacement = "MM.", rqigmods)
#setDF(datKME)
#datKME %>% dplyr::select(datKME, matches(paste(MMsigmods, collapse="|")))
#datKME[,c(sigmods)]
#sigmorphmodules <- datKME[,c("MM.pink", "MM.purple", "MM.grey")]
# loop to make ordered outputs for GOrilla
for (i in 1:length(MMrqigmods)){
modcol <- MMrqigmods[i]
# get data for module color
tmp <- datKME[,modcol]
gene_rows <- rownames(datKME)
tmp <- as.data.frame(cbind(gene_rows, as.numeric(tmp)))
colnames(tmp) <- c("gene", "module.membership")
tmp$module.membership <- as.numeric(as.character(tmp$module.membership))
tmp <- tmp[order(tmp[2], decreasing = TRUE), ]
write.csv(tmp, paste0("results/WGCNAresults/rq_", modcol, "ModuleMembership.csv"), row.names = FALSE)
}
MMh2oigmods <- gsub(pattern = "ME", replacement = "MM.", h2oigmods)
#setDF(datKME)
#datKME %>% dplyr::select(datKME, matches(paste(MMsigmods, collapse="|")))
#datKME[,c(sigmods)]
#sigmorphmodules <- datKME[,c("MM.pink", "MM.purple", "MM.grey")]
# loop to make ordered outputs for GOrilla
for (i in 1:length(MMh2oigmods)){
modcol <- MMh2oigmods[i]
# get data for module color
tmp <- datKME[,modcol]
gene_rows <- rownames(datKME)
tmp <- as.data.frame(cbind(gene_rows, as.numeric(tmp)))
colnames(tmp) <- c("gene", "module.membership")
tmp$module.membership <- as.numeric(as.character(tmp$module.membership))
tmp <- tmp[order(tmp[2], decreasing = TRUE), ]
write.csv(tmp, paste0("results/WGCNAresults/h2o_", modcol, "ModuleMembership.csv"), row.names = FALSE)
}
# countdata
#WGCNAdata <- countdata
#names(WGCNAdata)=str_sub(names(WGCNAdata),2)
#  #read.table("data/gene.level.count.data.tsv", header = TRUE, sep = "\t")
## sample information
#WGCNAsamples <- read.csv("results/samplespreadsheet.csv")
#WGCNAdata <- dplyr::select(countdata, contains("kid"))
#WGCNAsamples <-samples %>% filter(tissue == "kid")
memory.limit(size=2500)
#kept running out of space
WGCNAdata <- dplyr::select(countdata, contains("lu"))
WGCNAsamples <-samples %>% filter(tissue == "lu")
#
#WGCNAdata <- dplyr::select(countdata, contains("liv"))
#WGCNAsamples <-samples %>% filter(tissue == "liv")
#
#WGCNAdata <- dplyr::select(countdata, contains("hyp"))
#WGCNAsamples <-samples %>% filter(tissue == "hyp")
#
#WGCNAdata <- dplyr::select(countdata, contains("gi"))
#WGCNAsamples <-samples %>% filter(tissue == "gi")
# create DESeq dataset
dds <- DESeqDataSetFromMatrix(countData = WGCNAdata,
colData = WGCNAsamples,
design = ~ sex + trt )
## using counts imported via tximports from above
vsd <- vst(dds, blind = FALSE)
vsd <- assay(vsd)
# transpose, as required by WGCNA
vsd <- as.data.frame(t(vsd))
# check if there are gene outliers
gsg = goodSamplesGenes(vsd, verbose = 3)
gsg$allOK
# remove any offenders
#if (!gsg$allOK)
#  {if (sum(!gsg$goodGenes)>0)
#printFlush(paste("Removing genes:", paste(names(vsd)[!gsg$goodGenes], collapse= ", ")));
#if (sum(!gsg$goodSamples)>0)
#printFlush(paste("Removing samples:", paste(rownames(vsd)[!gsg$goodSamples], collapse=", ")))
#vsd <- vsd[gsg$goodSamples, gsg$goodGenes]
#}
# verify data and sample information align
table(WGCNAsamples$individal==rownames(vsd))
# drop lane
#WGCNAsamples <- dplyr::select(WGCNAsamples, -c(filename,lane))
# make sample id row name...
WGCNAsamples <- data.frame(WGCNAsamples[,-1], row.names=WGCNAsamples[,1])
A = adjacency(t(vsd),type="signed") # this calculates the whole network connectivity
k = as.numeric(apply(A,2,sum))-1 # standardized connectivity
Z.k = scale(k)
thresholdZ.k = -2.5 # often -2.5
outlierColor = ifelse(Z.k<thresholdZ.k,"red","black")
sampleTree = flashClust(as.dist(1-A), method = "average")
# Convert traits to a color representation where red indicates high values
# needs to be numeric
WGCNAsamples$sex <- as.numeric(as.factor(WGCNAsamples$sex))
WGCNAsamples$trt <- as.numeric(as.factor(WGCNAsamples$trt))
#WGCNAsamples$tissue <- as.numeric(as.factor(WGCNAsamples$tissue))
drop <- c("experiment.", "filename", "sample", "tissue", "individal")
WGCNAsamples <- WGCNAsamples[,!(names(WGCNAsamples) %in% drop)]
traitColors = data.frame(numbers2colors(WGCNAsamples,signed=FALSE))
dimnames(traitColors)[[2]] = paste(names(WGCNAsamples))
datColors = data.frame(outlier = outlierColor,traitColors)
plotDendroAndColors(sampleTree,groupLabels=names(datColors),
colors=datColors,main="Sample Dendrogram and Trait Heatmap")
powers = c(c(1:10), seq(from =10, to=30, by=1)) #choosing a set of soft-thresholding powers
sft = pickSoftThreshold(vsd, powerVector=powers, verbose =5, networkType="signed") #call network topology analysis function
#WGCNAdata <- dplyr::select(countdata, contains("kid"))
#WGCNAsamples <-samples %>% filter(tissue == "kid")
cd ~
touch .Renviron
touch .Renviron
#Set our working directory.
#This helps avoid confusion if our working directory is
#not our site because of other projects we were
#working on at the time.
setwd("~/Documents/DaniBlumstein.github.io")
#render your sweet site.
rmarkdown::render_site()
#Set our working directory.
#This helps avoid confusion if our working directory is
#not our site because of other projects we were
#working on at the time.
setwd("~/Documents/DaniBlumstein.github.io")
#render your sweet site.
rmarkdown::render_site()
#Set our working directory.
#This helps avoid confusion if our working directory is
#not our site because of other projects we were
#working on at the time.
setwd("~/Documents/DaniBlumstein.github.io")
#render your sweet site.
rmarkdown::render_site()
#Set our working directory.
#This helps avoid confusion if our working directory is
#not our site because of other projects we were
#working on at the time.
setwd("~/Documents/DaniBlumstein.github.io")
#render your sweet site.
rmarkdown::render_site()
#Set our working directory.
#This helps avoid confusion if our working directory is
#not our site because of other projects we were
#working on at the time.
setwd("~/Documents/DaniBlumstein.github.io")
#render your sweet site.
rmarkdown::render_site()
#Set our working directory.
#This helps avoid confusion if our working directory is
#not our site because of other projects we were
#working on at the time.
setwd("~/Documents/DaniBlumstein.github.io")
#render your sweet site.
rmarkdown::render_site()
#Set our working directory.
#This helps avoid confusion if our working directory is
#not our site because of other projects we were
#working on at the time.
setwd("~/Documents/DaniBlumstein.github.io")
#render your sweet site.
rmarkdown::render_site()
#Set our working directory.
#This helps avoid confusion if our working directory is
#not our site because of other projects we were
#working on at the time.
setwd("~/Documents/DaniBlumstein.github.io")
#render your sweet site.
rmarkdown::render_site()
#Set our working directory.
#This helps avoid confusion if our working directory is
#not our site because of other projects we were
#working on at the time.
setwd("~/Documents/DaniBlumstein.github.io")
#render your sweet site.
rmarkdown::render_site()
